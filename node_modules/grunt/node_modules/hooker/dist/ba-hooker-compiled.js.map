{"version":3,"sources":["ba-hooker.js"],"names":[],"mappings":"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","file":"ba-hooker-compiled.js","sourcesContent":["/*! JavaScript Hooker - v0.2.3 - 1/29/2012\n* http://github.com/cowboy/javascript-hooker\n* Copyright (c) 2012 \"Cowboy\" Ben Alman; Licensed MIT */\n\n(function(exports) {\n  // Get an array from an array-like object with slice.call(arrayLikeObject).\n  var slice = [].slice;\n  // Get an \"[object [[Class]]]\" string with toString.call(value).\n  var toString = {}.toString;\n\n  // I can't think of a better way to ensure a value is a specific type other\n  // than to create instances and use the `instanceof` operator.\n  function HookerOverride(v) { this.value = v; }\n  function HookerPreempt(v) { this.value = v; }\n  function HookerFilter(c, a) { this.context = c; this.args = a; }\n\n  // When a pre- or post-hook returns the result of this function, the value\n  // passed will be used in place of the original function's return value. Any\n  // post-hook override value will take precedence over a pre-hook override\n  // value.\n  exports.override = function(value) {\n    return new HookerOverride(value);\n  };\n\n  // When a pre-hook returns the result of this function, the value passed will\n  // be used in place of the original function's return value, and the original\n  // function will NOT be executed.\n  exports.preempt = function(value) {\n    return new HookerPreempt(value);\n  };\n\n  // When a pre-hook returns the result of this function, the context and\n  // arguments passed will be applied into the original function.\n  exports.filter = function(context, args) {\n    return new HookerFilter(context, args);\n  };\n\n  // Execute callback(s) for properties of the specified object.\n  function forMethods(obj, props, callback) {\n    var prop;\n    if (typeof props === \"string\") {\n      // A single prop string was passed. Create an array.\n      props = [props];\n    } else if (props == null) {\n      // No props were passed, so iterate over all properties, building an\n      // array. Unfortunately, Object.keys(obj) doesn't work everywhere yet, so\n      // this has to be done manually.\n      props = [];\n      for (prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          props.push(prop);\n        }\n      }\n    }\n    // Execute callback for every method in the props array.\n    var i = props.length;\n    while (i--) {\n      // If the property isn't a function...\n      if (toString.call(obj[props[i]]) !== \"[object Function]\" ||\n        // ...or the callback returns false...\n        callback(obj, props[i]) === false) {\n        // ...remove it from the props array to be returned.\n        props.splice(i, 1);\n      }\n    }\n    // Return an array of method names for which the callback didn't fail.\n    return props;\n  }\n\n  // Monkey-patch (hook) a method of an object.\n  exports.hook = function(obj, props, options) {\n    // If the props argument was omitted, shuffle the arguments.\n    if (options == null) {\n      options = props;\n      props = null;\n    }\n    // If just a function is passed instead of an options hash, use that as a\n    // pre-hook function.\n    if (typeof options === \"function\") {\n      options = {pre: options};\n    }\n\n    // Hook the specified method of the object.\n    return forMethods(obj, props, function(obj, prop) {\n      // The original (current) method.\n      var orig = obj[prop];\n      // The new hooked function.\n      function hooked() {\n        var result, origResult, tmp;\n\n        // Get an array of arguments.\n        var args = slice.call(arguments);\n\n        // If passName option is specified, prepend prop to the args array,\n        // passing it as the first argument to any specified hook functions.\n        if (options.passName) {\n          args.unshift(prop);\n        }\n\n        // If a pre-hook function was specified, invoke it in the current\n        // context with the passed-in arguments, and store its result.\n        if (options.pre) {\n          result = options.pre.apply(this, args);\n        }\n\n        if (result instanceof HookerFilter) {\n          // If the pre-hook returned hooker.filter(context, args), invoke the\n          // original function with that context and arguments, and store its\n          // result.\n          origResult = result = orig.apply(result.context, result.args);\n        } else if (result instanceof HookerPreempt) {\n          // If the pre-hook returned hooker.preempt(value) just use the passed\n          // value and don't execute the original function.\n          origResult = result = result.value;\n        } else {\n          // Invoke the original function in the current context with the\n          // passed-in arguments, and store its result.\n          origResult = orig.apply(this, arguments);\n          // If the pre-hook returned hooker.override(value), use the passed\n          // value, otherwise use the original function's result.\n          result = result instanceof HookerOverride ? result.value : origResult;\n        }\n\n        if (options.post) {\n          // If a post-hook function was specified, invoke it in the current\n          // context, passing in the result of the original function as the\n          // first argument, followed by any passed-in arguments.\n          tmp = options.post.apply(this, [origResult].concat(args));\n          if (tmp instanceof HookerOverride) {\n            // If the post-hook returned hooker.override(value), use the passed\n            // value, otherwise use the previously computed result.\n            result = tmp.value;\n          }\n        }\n\n        // Unhook if the \"once\" option was specified.\n        if (options.once) {\n          exports.unhook(obj, prop);\n        }\n\n        // Return the result!\n        return result;\n      }\n      // Re-define the method.\n      obj[prop] = hooked;\n      // Fail if the function couldn't be hooked.\n      if (obj[prop] !== hooked) { return false; }\n      // Store a reference to the original method as a property on the new one.\n      obj[prop]._orig = orig;\n    });\n  };\n\n  // Get a reference to the original method from a hooked function.\n  exports.orig = function(obj, prop) {\n    return obj[prop]._orig;\n  };\n\n  // Un-monkey-patch (unhook) a method of an object.\n  exports.unhook = function(obj, props) {\n    return forMethods(obj, props, function(obj, prop) {\n      // Get a reference to the original method, if it exists.\n      var orig = exports.orig(obj, prop);\n      // If there's no original method, it can't be unhooked, so fail.\n      if (!orig) { return false; }\n      // Unhook the method.\n      obj[prop] = orig;\n    });\n  };\n}(typeof exports === \"object\" && exports || this));\n"]}