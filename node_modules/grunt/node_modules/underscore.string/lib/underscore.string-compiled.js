// Underscore.string
// (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
// Underscore.strings is freely distributable under the terms of the MIT license.
// Documentation: https://github.com/epeli/underscore.string
// Some code is borrowed from MooTools and Alexandru Marasteanu.

// Version 2.2.0rc

'use strict';

(function (root) {
  'use strict';

  // Defining helper functions.

  var nativeTrim = String.prototype.trim;
  var nativeTrimRight = String.prototype.trimRight;
  var nativeTrimLeft = String.prototype.trimLeft;

  var parseNumber = function parseNumber(source) {
    return source * 1 || 0;
  };

  var strRepeat = function strRepeat(str, qty, separator) {
    // ~~var — is the fastest available way to convert anything to Integer in javascript.
    // We'll use it extensively in this lib.
    str += '';qty = ~ ~qty;
    for (var repeat = []; qty > 0; repeat[--qty] = str) {}
    return repeat.join(separator == null ? '' : separator);
  };

  var slice = function slice(a) {
    return Array.prototype.slice.call(a);
  };

  var defaultToWhiteSpace = function defaultToWhiteSpace(characters) {
    if (characters != null) {
      return '[' + _s.escapeRegExp('' + characters) + ']';
    }
    return '\\s';
  };

  var escapeChars = {
    lt: '<',
    gt: '>',
    quot: '"',
    apos: '\'',
    amp: '&'
  };

  var reversedEscapeChars = {};
  for (var key in escapeChars) {
    reversedEscapeChars[escapeChars[key]] = key;
  }

  // sprintf() for JavaScript 0.7-beta1
  // http://www.diveintojavascript.com/projects/javascript-sprintf
  //
  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
  // All rights reserved.

  var sprintf = (function () {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }

    var str_repeat = strRepeat;

    var str_format = function str_format() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function (parse_tree, argv) {
      var cursor = 1,
          tree_length = parse_tree.length,
          node_type = '',
          arg,
          output = [],
          i,
          k,
          match,
          pad,
          pad_character,
          pad_length;
      for (i = 0; i < tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === 'string') {
          output.push(parse_tree[i]);
        } else if (node_type === 'array') {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) {
            // keyword argument
            arg = argv[cursor];
            for (k = 0; k < match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          } else if (match[1]) {
            // positional argument (explicit)
            arg = argv[match[1]];
          } else {
            // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
          }
          switch (match[8]) {
            case 'b':
              arg = arg.toString(2);break;
            case 'c':
              arg = String.fromCharCode(arg);break;
            case 'd':
              arg = parseInt(arg, 10);break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);break;
            case 'o':
              arg = arg.toString(8);break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;break;
            case 'u':
              arg = Math.abs(arg);break;
            case 'x':
              arg = arg.toString(16);break;
            case 'X':
              arg = arg.toString(16).toUpperCase();break;
          }
          arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function (fmt) {
      var _fmt = fmt,
          match = [],
          parse_tree = [],
          arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push('%');
        } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [],
                replacement_field = match[2],
                field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new Error('[_.sprintf] huh?');
                }
              }
            } else {
              throw new Error('[_.sprintf] huh?');
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
          }
          parse_tree.push(match);
        } else {
          throw new Error('[_.sprintf] huh?');
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();

  // Defining underscore.string

  var _s = {

    VERSION: '2.2.0rc',

    isBlank: function isBlank(str) {
      return /^\s*$/.test(str);
    },

    stripTags: function stripTags(str) {
      return ('' + str).replace(/<\/?[^>]+>/g, '');
    },

    capitalize: function capitalize(str) {
      str += '';
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    chop: function chop(str, step) {
      str = str + '';
      step = ~ ~step || str.length;
      var arr = [];
      for (var i = 0; i < str.length; i += step) arr.push(str.slice(i, i + step));
      return arr;
    },

    clean: function clean(str) {
      return _s.strip(str).replace(/\s+/g, ' ');
    },

    count: function count(str, substr) {
      str += '';substr += '';
      return str.split(substr).length - 1;
    },

    chars: function chars(str) {
      return ('' + str).split('');
    },

    escapeHTML: function escapeHTML(str) {
      return ('' + str).replace(/[&<>"']/g, function (match) {
        return '&' + reversedEscapeChars[match] + ';';
      });
    },

    unescapeHTML: function unescapeHTML(str) {
      return ('' + str).replace(/\&([^;]+);/g, function (entity, entityCode) {
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~ ~match[1]);
        } else {
          return entity;
        }
      });
    },

    escapeRegExp: function escapeRegExp(str) {
      // From MooTools core 1.2.4
      return str.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
    },

    insert: function insert(str, i, substr) {
      var arr = _s.chars(str);
      arr.splice(~ ~i, 0, '' + substr);
      return arr.join('');
    },

    include: function include(str, needle) {
      return !! ~('' + str).indexOf(needle);
    },

    join: function join() {
      var args = slice(arguments);
      return args.join(args.shift());
    },

    lines: function lines(str) {
      return ('' + str).split('\n');
    },

    reverse: function reverse(str) {
      return _s.chars(str).reverse().join('');
    },

    splice: function splice(str, i, howmany, substr) {
      var arr = _s.chars(str);
      arr.splice(~ ~i, ~ ~howmany, substr);
      return arr.join('');
    },

    startsWith: function startsWith(str, starts) {
      str += '';starts += '';
      return str.length >= starts.length && str.substring(0, starts.length) === starts;
    },

    endsWith: function endsWith(str, ends) {
      str += '';ends += '';
      return str.length >= ends.length && str.substring(str.length - ends.length) === ends;
    },

    succ: function succ(str) {
      str += '';
      var arr = _s.chars(str);
      arr.splice(str.length - 1, 1, String.fromCharCode(str.charCodeAt(str.length - 1) + 1));
      return arr.join('');
    },

    titleize: function titleize(str) {
      return ('' + str).replace(/\b./g, function (ch) {
        return ch.toUpperCase();
      });
    },

    camelize: function camelize(str) {
      return _s.trim(str).replace(/[-_\s]+(.)?/g, function (match, chr) {
        return chr && chr.toUpperCase();
      });
    },

    underscored: function underscored(str) {
      return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
    },

    dasherize: function dasherize(str) {
      return _s.trim(str).replace(/[_\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();
    },

    classify: function classify(str) {
      str += '';
      return _s.titleize(str.replace(/_/g, ' ')).replace(/\s/g, '');
    },

    humanize: function humanize(str) {
      return _s.capitalize(this.underscored(str).replace(/_id$/, '').replace(/_/g, ' '));
    },

    trim: function trim(str, characters) {
      str += '';
      if (!characters && nativeTrim) {
        return nativeTrim.call(str);
      }
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
    },

    ltrim: function ltrim(str, characters) {
      str += '';
      if (!characters && nativeTrimLeft) {
        return nativeTrimLeft.call(str);
      }
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp('^' + characters + '+'), '');
    },

    rtrim: function rtrim(str, characters) {
      str += '';
      if (!characters && nativeTrimRight) {
        return nativeTrimRight.call(str);
      }
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp(characters + '+$'), '');
    },

    truncate: function truncate(str, length, truncateStr) {
      str += '';truncateStr = truncateStr || '...';
      length = ~ ~length;
      return str.length > length ? str.slice(0, length) + truncateStr : str;
    },

    /**
     * _s.prune: a more elegant version of truncate
     * prune extra chars, never leaving a half-chopped word.
     * @author github.com/sergiokas
     */
    prune: function prune(str, length, pruneStr) {
      str += '';length = ~ ~length;
      pruneStr = pruneStr != null ? '' + pruneStr : '...';

      var pruned,
          borderChar,
          template = str.replace(/\W/g, function (ch) {
        return ch.toUpperCase() !== ch.toLowerCase() ? 'A' : ' ';
      });

      borderChar = template.charAt(length);

      pruned = template.slice(0, length);

      // Check if we're in the middle of a word
      if (borderChar && borderChar.match(/\S/)) pruned = pruned.replace(/\s\S+$/, '');

      pruned = _s.rtrim(pruned);

      return (pruned + pruneStr).length > str.length ? str : str.substring(0, pruned.length) + pruneStr;
    },

    words: function words(str, delimiter) {
      return _s.trim(str, delimiter).split(delimiter || /\s+/);
    },

    pad: function pad(str, length, padStr, type) {
      str += '';

      var padlen = 0;

      length = ~ ~length;

      if (!padStr) {
        padStr = ' ';
      } else if (padStr.length > 1) {
        padStr = padStr.charAt(0);
      }

      switch (type) {
        case 'right':
          padlen = length - str.length;
          return str + strRepeat(padStr, padlen);
        case 'both':
          padlen = length - str.length;
          return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
        default:
          // 'left'
          padlen = length - str.length;
          return strRepeat(padStr, padlen) + str;
      }
    },

    lpad: function lpad(str, length, padStr) {
      return _s.pad(str, length, padStr);
    },

    rpad: function rpad(str, length, padStr) {
      return _s.pad(str, length, padStr, 'right');
    },

    lrpad: function lrpad(str, length, padStr) {
      return _s.pad(str, length, padStr, 'both');
    },

    sprintf: sprintf,

    vsprintf: function vsprintf(fmt, argv) {
      argv.unshift(fmt);
      return sprintf.apply(null, argv);
    },

    toNumber: function toNumber(str, decimals) {
      str += '';
      var num = parseNumber(parseNumber(str).toFixed(~ ~decimals));
      return num === 0 && !str.match(/^0+$/) ? Number.NaN : num;
    },

    strRight: function strRight(str, sep) {
      str += '';sep = sep != null ? '' + sep : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(pos + sep.length, str.length) : str;
    },

    strRightBack: function strRightBack(str, sep) {
      str += '';sep = sep != null ? '' + sep : sep;
      var pos = !sep ? -1 : str.lastIndexOf(sep);
      return ~pos ? str.slice(pos + sep.length, str.length) : str;
    },

    strLeft: function strLeft(str, sep) {
      str += '';sep = sep != null ? '' + sep : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    strLeftBack: function strLeftBack(str, sep) {
      str += '';sep = sep != null ? '' + sep : sep;
      var pos = str.lastIndexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    toSentence: function toSentence(array, separator, lastSeparator) {
      separator || (separator = ', ');
      lastSeparator || (lastSeparator = ' and ');
      var length = array.length,
          str = '';

      for (var i = 0; i < length; i++) {
        str += array[i];
        if (i === length - 2) {
          str += lastSeparator;
        } else if (i < length - 1) {
          str += separator;
        }
      }

      return str;
    },

    slugify: function slugify(str) {
      var from = 'ąàáäâãćęèéëêìíïîłńòóöôõùúüûñçżź',
          to = 'aaaaaaceeeeeiiiilnooooouuuunczz',
          regex = new RegExp(defaultToWhiteSpace(from), 'g');

      str = ('' + str).toLowerCase();

      str = str.replace(regex, function (ch) {
        var index = from.indexOf(ch);
        return to.charAt(index) || '-';
      });

      return _s.trim(str.replace(/[^\w\s-]/g, '').replace(/[-\s]+/g, '-'), '-');
    },

    exports: function exports() {
      var result = {};

      for (var prop in this) {
        if (!this.hasOwnProperty(prop) || ~_s.words('include contains reverse').indexOf(prop)) continue;
        result[prop] = this[prop];
      }

      return result;
    },

    repeat: strRepeat
  };

  // Aliases

  _s.strip = _s.trim;
  _s.lstrip = _s.ltrim;
  _s.rstrip = _s.rtrim;
  _s.center = _s.lrpad;
  _s.rjust = _s.lpad;
  _s.ljust = _s.rpad;
  _s.contains = _s.include;

  // CommonJS module is defined
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      // Export module
      module.exports = _s;
    }
    exports._s = _s;
  } else if (typeof define === 'function' && define.amd) {
    // Register as a named module with AMD.
    define('underscore.string', function () {
      return _s;
    });
  } else {
    // Integrate with Underscore.js if defined
    // or create our own underscore object.
    root._ = root._ || {};
    root._.string = root._.str = _s;
  }
})(undefined || window);

//# sourceMappingURL=underscore.string-compiled.js.map