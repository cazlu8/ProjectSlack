'use strict';

var vows = require('vows'),
    assert = require('assert'),
    iconv = require(__dirname + '/../');

var ascii = '\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f' + ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';

var encodings = [{
    name: 'windows1254',
    variations: ['windows-1254', 'win-1254', 'win1254', 'cp1254', 'cp-1254', 1254],
    strings: {
        empty: '',
        ascii: ascii,
        turkish: '€‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ',
        untranslatable: ''
    },
    encodedStrings: {
        empty: new Buffer(''),
        ascii: new Buffer(ascii, 'binary'),
        turkish: new Buffer('' + '' + '¡¢£¤¥¦§¨©ª«¬®¯' + '°±²³´µ¶·¸¹º»¼½¾¿' + 'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ' + 'ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß' + 'àáâãäåæçèéêëìíîï' + 'ðñòóôõö÷øùúûüýþÿ', 'binary') }
}, {
    name: 'iso88599',
    variations: ['iso-8859-9', 'turkish', 'turkish8', 'cp28599', 'cp-28599', 28599],
    strings: {
        empty: '',
        ascii: ascii,
        turkish: ' ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ',
        untranslatable: ''
    },
    encodedStrings: {
        empty: new Buffer(''),
        ascii: new Buffer(ascii, 'binary'),
        turkish: new Buffer(' ¡¢£¤¥¦§¨©ª«¬­®¯' + '°±²³´µ¶·¸¹º»¼½¾¿' + 'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ' + 'ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß' + 'àáâãäåæçèéêëìíîï' + 'ðñòóôõö÷øùúûüýþÿ', 'binary')
    }
}];

var testsBatch = {};
encodings.forEach(function (encoding) {
    var enc = encoding.variations[0];
    var key = 'turkish';
    var tests = {
        'Convert to empty buffer': function ConvertToEmptyBuffer() {
            assert.strictEqual(iconv.toEncoding('', enc).toString('binary'), new Buffer('').toString('binary'));
        },
        'Convert from empty buffer': function ConvertFromEmptyBuffer() {
            assert.strictEqual(iconv.fromEncoding(new Buffer(''), enc), '');
        },
        'Convert from buffer': function ConvertFromBuffer() {
            for (var key in encoding.encodedStrings) assert.strictEqual(iconv.fromEncoding(encoding.encodedStrings[key], enc), encoding.strings[key]);
        },
        'Convert to buffer': function ConvertToBuffer() {
            for (var key in encoding.encodedStrings) assert.strictEqual(iconv.toEncoding(encoding.strings[key], enc).toString('binary'), encoding.encodedStrings[key].toString('binary'));
        },
        'Try different variations of encoding': function TryDifferentVariationsOfEncoding() {
            encoding.variations.forEach(function (enc) {
                assert.strictEqual(iconv.fromEncoding(encoding.encodedStrings[key], enc), encoding.strings[key]);
                assert.strictEqual(iconv.toEncoding(encoding.strings[key], enc).toString('binary'), encoding.encodedStrings[key].toString('binary'));
            });
        },
        'Untranslatable chars are converted to defaultCharSingleByte': function UntranslatableCharsAreConvertedToDefaultCharSingleByte() {
            var expected = encoding.strings.untranslatable.split('').map(function (c) {
                return iconv.defaultCharSingleByte;
            }).join('');
            assert.strictEqual(iconv.toEncoding(encoding.strings.untranslatable, enc).toString('binary'), expected); // Only '?' characters.
        }
    };

    testsBatch[encoding.name + ':'] = tests;
});

vows.describe('Test Turkish encodings').addBatch(testsBatch)['export'](module);

//# sourceMappingURL=turkish-test-compiled.js.map