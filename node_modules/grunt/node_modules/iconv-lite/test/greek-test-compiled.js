'use strict';

var vows = require('vows'),
    assert = require('assert'),
    iconv = require(__dirname + '/../');

var baseStrings = {
    empty: '',
    hi: 'Γειά!',
    ascii: '\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f' + ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',
    greek: 'αβγδεζηθικλμνξοπρστυφχψωΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩάέήίόύώΆΈΉΊΌΎΏϊϋΪΫ',
    untranslatable: 'Åçþÿ¿'
};

var encodings = [{
    name: 'windows1253',
    variations: ['windows-1253', 'win-1253', 'win1253', 'cp1253', 'cp-1253', 1253],
    encodedStrings: {
        empty: new Buffer(''),
        hi: new Buffer('ÃåéÜ!', 'binary'),
        ascii: new Buffer(baseStrings.ascii, 'binary'),
        greek: new Buffer('áâãäåæçèéêëìíîïðñóôõö÷øùÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÓÔÕÖ×ØÙÜÝÞßüýþ¢¸¹º¼¾¿úûÚÛ', 'binary') }
}, {
    name: 'iso88597',
    variations: ['iso-8859-7', 'greek', 'greek8', 'cp28597', 'cp-28597', 28597],
    encodedStrings: {
        empty: new Buffer(''),
        hi: new Buffer('ÃåéÜ!', 'binary'),
        ascii: new Buffer(baseStrings.ascii, 'binary'),
        greek: new Buffer('áâãäåæçèéêëìíîïðñóôõö÷øùÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÓÔÕÖ×ØÙÜÝÞßüýþ¶¸¹º¼¾¿úûÚÛ', 'binary') }
}, {
    name: 'cp737',
    variations: ['cp-737', 737],
    encodedStrings: {
        empty: new Buffer(''),
        hi: new Buffer(' á!', 'binary'),
        ascii: new Buffer(baseStrings.ascii, 'binary'),
        greek: new Buffer(' ¡¢£¤¥¦§¨©«¬­®¯àáâãåæçéêëìíîïðäèôõ', 'binary') }
}];

var testsBatch = {};
encodings.forEach(function (encoding) {
    var enc = encoding.variations[0];
    var key = 'hi';
    var tests = {
        'Convert to empty buffer': function ConvertToEmptyBuffer() {
            assert.strictEqual(iconv.toEncoding('', enc).toString('binary'), new Buffer('').toString('binary'));
        },
        'Convert from empty buffer': function ConvertFromEmptyBuffer() {
            assert.strictEqual(iconv.fromEncoding(new Buffer(''), enc), '');
        },
        'Convert from buffer': function ConvertFromBuffer() {
            for (var key in encoding.encodedStrings) assert.strictEqual(iconv.fromEncoding(encoding.encodedStrings[key], enc), baseStrings[key]);
        },
        'Convert to buffer': function ConvertToBuffer() {
            for (var key in encoding.encodedStrings) assert.strictEqual(iconv.toEncoding(baseStrings[key], enc).toString('binary'), encoding.encodedStrings[key].toString('binary'));
        },
        'Try different variations of encoding': function TryDifferentVariationsOfEncoding() {
            encoding.variations.forEach(function (enc) {
                assert.strictEqual(iconv.fromEncoding(encoding.encodedStrings[key], enc), baseStrings[key]);
                assert.strictEqual(iconv.toEncoding(baseStrings[key], enc).toString('binary'), encoding.encodedStrings[key].toString('binary'));
            });
        },
        'Untranslatable chars are converted to defaultCharSingleByte': function UntranslatableCharsAreConvertedToDefaultCharSingleByte() {
            var expected = baseStrings.untranslatable.split('').map(function (c) {
                return iconv.defaultCharSingleByte;
            }).join('');
            assert.strictEqual(iconv.toEncoding(baseStrings.untranslatable, enc).toString('binary'), expected); // Only '?' characters.
        }
    };

    testsBatch[encoding.name + ':'] = tests;
});

vows.describe('Test Greek encodings').addBatch(testsBatch)['export'](module);

//# sourceMappingURL=greek-test-compiled.js.map